use super::ident::*;

lexer Token ->
      RESERVED_TOKEN
    | RAW_IDENTIFIER
    | CHAR_LITERAL
    | STRING_LITERAL
    | RAW_STRING_LITERAL
    | BYTE_LITERAL
    | BYTE_STRING_LITERAL
    | RAW_BYTE_STRING_LITERAL
    | C_STRING_LITERAL
    | RAW_C_STRING_LITERAL
    | INTEGER_LITERAL
    | FLOAT_LITERAL
    | LIFETIME_TOKEN
    | PUNCTUATION
    | IDENTIFIER_OR_KEYWORD
    ;

lexer SUFFIX →
    IDENTIFIER_OR_KEYWORD except '_'
    ;

lexer SUFFIX_NO_E →
    SUFFIX prefix ~['e','E']
    ;

lexer CHAR_LITERAL →
    '\''
        ( ~['\'','\\',LF,CR,TAB] | QUOTE_ESCAPE | ASCII_ESCAPE | UNICODE_ESCAPE )
    '\'' SUFFIX?
    ;

lexer QUOTE_ESCAPE -> '\\\'' | '\\"'

lexer ASCII_ESCAPE →
    '\\x' OCT_DIGIT HEX_DIGIT
    | '\\n'
    | '\\r'
    | '\\t'
    | '\\\\'
    | '\\0'
    ;

lexer UNICODE_ESCAPE →
    '\\u{' (HEX_DIGIT _*){1..6} '}'
    ;


lexer STRING_LITERAL ->
    '"'
    (
        ~['"','\',CR]
      | QUOTE_ESCAPE
      | ASCII_ESCAPE
      | UNICODE_ESCAPE
      | STRING_CONTINUE
    )*
    '"' SUFFIX?
    ;

lexer STRING_CONTINUE →
    '\\' LF
    ;


lexer RAW_STRING_LITERAL ->
     'r' RAW_STRING_CONTENT SUFFIX?
     ;

lexer RAW_STRING_CONTENT ->
      '"' (~CR)* '"'
    | '#' RAW_STRING_CONTENT '#'


lexer BYTE_LITERAL →
    'b\'' ( ASCII_FOR_CHAR | BYTE_ESCAPE ) ''' SUFFIX?
    ;

lexer ASCII_FOR_CHAR ->
    [U+0000-U+007f] except ['\'','\\',LF,CR,TAB]
    ;

BYTE_ESCAPE →
    '\\x' HEX_DIGIT HEX_DIGIT
    | '\\n'
    | '\\r'
    | '\\t'
    | '\\\\'
    | '\\0'
    | '\\\''
    | '\\"'
    ;


lexer BYTE_STRING_LITERAL ->
    'b"' ( ASCII_FOR_STRING | BYTE_ESCAPE | STRING_CONTINUE )* '"' SUFFIX?
    ;

lexer ASCII_FOR_STRING ->
    [U+0000-U+007f] except ['\'','\\',LF,CR,TAB]
    ;

lexer RAW_BYTE_STRING_LITERAL ->
    'br' RAW_BYTE_STRING_CONTENT SUFFIX?
    ;

lexer RAW_BYTE_STRING_CONTENT ->
      '"' ASCII_FOR_RAW* '"'
    | '#' RAW_BYTE_STRING_CONTENT '#'
    ;

lexer ASCII_FOR_RAW ->
    [U+0000-U+007f] except TAB
    ;

lexer C_STRING_LITERAL →
    'c"'
    (
        ~['"','\\',CR,NUL]
      | BYTE_ESCAP escept ['\\0','\\x00']
      | UNICODE_ESCAP except ['\\u{0}', '\\u{00}', '\\u{000}', '\\u{0000}', '\\u{00000}', '\\u{000000}']
      | STRING_CONTINUE
    )*
    '"'
    SUFFIX?
    ;

lexer RAW_C_STRING_LITERAL ->
    'cr' RAW_C_STRING_CONTENT SUFFIX?;

lexer RAW_C_STRING_CONTENT ->
      '"' (~[CR,NUL])* '"'
    | '#' RAW_C_STRING_CONTENT '#'
    ;


lexer INTEGER_LITERAL ->
    ( DEC_LITERAL | BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) SUFFIX_NO_E?
    ;

lexer DEC_LITERAL ->
     DEC_DIGIT ( DEC_DIGIT | _ )*
     ;

lexer BIN_LITERAL ->
    '0b' ( BIN_DIGIT | _ )* BIN_DIGIT ( BIN_DIGIT | _ )*
    ;

lexer OCT_LITERAL ->
    '0o' ( OCT_DIGIT | _ )* OCT_DIGIT ( OCT_DIGIT | _ )*
    ;

lexer HEX_LITERAL ->
    '0x' ( HEX_DIGIT | _ )* HEX_DIGIT ( HEX_DIGIT | _ )*
    ;

lexer BIN_DIGIT ->
    ['0'-'1']
    ;

lexer OCT_DIGIT ->
    ['0'-'7']
    ;

lexer DEC_DIGIT ->
    ['0'-'9']
    ;

lexer HEX_DIGIT ->
    ['0'-'9','a'-'f','A'-'F']
    ;

lexer TUPLE_INDEX ->
    DEC_LITERAL | BIN_LITERAL | OCT_LITERAL | HEX_LITERAL
    ;

lexer FLOAT_LITERAL ->
      DEC_LITERAL '.' followed ~['.',',','_',XID_Start]
    | DEC_LITERAL '.' DEC_LITERAL SUFFIX_NO_E?
    | DEC_LITERAL ('.' DEC_LITERAL )? FLOAT_EXPONENT SUFFIX?
    ;

lexer FLOAT_EXPONENT ->
    ( 'e' | 'E' ) ( '+' | '-' )? ( DEC_DIGIT | '_' )* DEC_DIGIT ( DEC_DIGIT | '_' )*
    ;

lexer RESERVED_NUMBER ->
      BIN_LITERAL ['2'-'9']
    | OCT_LITERAL ['8'-'9']
    | ( BIN_LITERAL | OCT_LITERAL | HEX_LITERAL ) '.' followed ~['.',',','_',XID_Start]
    | ( BIN_LITERAL | OCT_LITERAL ) ( e | E )
    | 0b _* followed ($ | ~BIN_DIGIT)
    | 0o _* followed ($ | ~OCT_DIGIT)
    | 0x _* followed ($ | ~HEX_DIGIT)
    | DEC_LITERAL ( '.' DEC_LITERAL )? ( 'e' | 'E' ) ( '+' | '-' )? ($ | ~DEC_DIGIT)
    ;

lexer LIFETIME_TOKEN →
      '\'' IDENTIFIER_OR_KEYWORD followed ~'\''
    | RAW_LIFETIME
    ;

lexer LIFETIME_OR_LABEL ->
      '\'' NON_KEYWORD_IDENTIFIER followed ~'\''
    | RAW_LIFETIME
    ;

lexer RAW_LIFETIME ->
    '\'r#' IDENTIFIER_OR_KEYWORD followed ~'\''
    ;

lexer RESERVED_RAW_LIFETIME ->
    '\'r#' ( '_' | 'crate' | 'self' | 'Self' | 'super' ) followed ~'\''
    ;

lexer PUNCTUATION →
      '='
    | '<'
    | '<='
    | '=='
    | '!='
    | '>='
    | '>'
    | '&&'
    | '||'
    | '!'
    | '~'
    | '+'
    | '-'
    | '*'
    | '/'
    | '%'
    | '^'
    | '&'
    | '|'
    | '<<'
    | '>>'
    | '+='
    | '-='
    | '*='
    | '/='
    | '%='
    | '^='
    | '&='
    | '|='
    | '<<='
    | '>>='
    | '@'
    | '.'
    | '..'
    | '...'
    | '..='
    | ','
    | ';'
    | ':'
    | '::'
    | '->'
    | '<-'
    | '=>'
    | '#'
    | '$'
    | '?'
    | '{'
    | '}'
    | '['
    | ']'
    | '('
    | ')'
    ;

lexer RESERVED_TOKEN ->
      RESERVED_GUARDED_STRING_LITERAL
    | RESERVED_NUMBER
    | RESERVED_POUNDS
    | RESERVED_RAW_IDENTIFIER
    | RESERVED_RAW_LIFETIME
    | RESERVED_TOKEN_DOUBLE_QUOTE
    | RESERVED_TOKEN_LIFETIME
    | RESERVED_TOKEN_POUND
    | RESERVED_TOKEN_SINGLE_QUOTE
    ;

lexer RESERVED_TOKEN_DOUBLE_QUOTE ->
    IDENTIFIER_OR_KEYWORD except ['b','c','r','br','cr'] '"'
    ;

lexer RESERVED_TOKEN_SINGLE_QUOTE ->
    IDENTIFIER_OR_KEYWORD except 'b' '\''
    ;

lexer RESERVED_TOKEN_POUND ->
    IDENTIFIER_OR_KEYWORD except ['r','br','cr'] '#'
    ;

lexer RESERVED_TOKEN_LIFETIME ->
    ' IDENTIFIER_OR_KEYWORD except 'r' #
    ;

lexer RESERVED_GUARDED_STRING_LITERAL ->
    '#'+ STRING_LITERAL
    ;

RESERVED_POUNDS ->
    '#'{2..}
    ;
